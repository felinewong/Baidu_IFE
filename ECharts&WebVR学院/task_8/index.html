<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>TEST</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
		body {
			font-family: Monospace;
			color: #fff;
			margin: 0px;
			overflow: hidden;
		}
        .score_container {
            position: absolute;
            top: 10px;
            left: 50%;
            margin-left: -122px;
        }
        .score_container #score {
            color: #ff0000;
            font-size: 50px;
        }
	</style>
</head>
<body >
    <div class="score_container">
        <div id="score">0</div>
    </div>
    <audio src="sound/explode.mp3" preload="auto" id="explode_sound"></audio>

    <script type="text/javascript" src="../lib/three.min.js"></script>
    <script type="text/javascript" src="../lib/OrbitControls.js"></script>
    <script type="text/javascript" src="../lib/Detector.js"></script>
    <script type="text/javascript" src="../lib/stat.js"></script>
    <script type="text/javascript" src="../lib/zepto.js"></script>
    <script type="text/javascript" src="../lib/dat.gui.min.js"></script>
    <script type="text/javascript" src="../lib/BabylonLoader.js"></script>
    <script type="text/javascript" src="../lib/physi.js"></script>
    <script type="text/javascript" src="../lib/simplex-noise.js"></script>
    <script type="text/javascript">

        'use strict';
        Physijs.scripts.ammo = 'ammo.js';
        Physijs.scripts.worker = 'js/physijs_worker.js';
        

        var explode_sound = document.getElementById('explode_sound'),
            score = document.getElementById('score'),
            stat = null,
            scene = null,
            renderer = null,
            camera = null,
            controls = null,
            NoiseGen = null,
            noneMat = null,

            model = null,
            car = null,
            wheelArr = [],

            plane_material = null,
            plane_geometry = null,
            plane = null,


            keyLight = null,
            backLight = null,

            shaders = [],
            shaderConfig = null,

            gui = null,

            rotate = 0,
            collideMeshList = [],
            //标志碰撞是否发生
            crash = false;

     
        window.onload = init;
           
        function init(){
            //探测器
            if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

            //监测帧数
            stat = new Stats();
            stat.domElement.style.position = 'absolute';
            stat.domElement.style.left = '0px';
            stat.domElement.style.top = '0px';
            document.body.appendChild(stat.domElement);

            //renderer 并添加到dom树中
            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0xf3f3f3);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.soft = true;
            document.body.appendChild( renderer.domElement);

            //scene
            //scene = new THREE.Scene();
            scene = new Physijs.Scene;
            scene.setGravity(new THREE.Vector3(0, -30, 0));
            scene.addEventListener(
			    'update',
			    function() {
				    //applyForce();
				    scene.simulate( undefined, 1 );
				    //physics_stats.update();
			    }
		    );


             //camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(-85,94,-96);
            scene.add(camera);
 
            //controls
            controls = new THREE.OrbitControls( camera, renderer.domElement );
            controls.addEventListener('change', render);
            

            // texture
            var manager = new THREE.LoadingManager();
            manager.onProgress = function(item, loaded, total){
                console.log(item, loaded, total);
            }

            var onProgress = function(xhr){
                if(xhr.lengthComputable){
                    var percentComplete = xhr.loaded / xhr.total * 100;
                    console.log(Math.round(percentComplete,2) + "% downloaded");
                }
            }

            var onError = function(xhr){

            }


            var texture = THREE.ImageUtils.loadTexture('img/rocks.jpg',{},function(){
                renderer.render(scene, camera);
            });
            texture.wraps = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1,1);     
            // ground
            plane_material = Physijs.createMaterial(
                new THREE.MeshLambertMaterial({
                    map: texture
                })
            );

            NoiseGen = new SimplexNoise;
            
            var plane_geometry = new THREE.PlaneGeometry(100,100,50,50);
            for(var i=0; i<plane_geometry.vertices.length; i++){
                var vertex = plane_geometry.vertices[i];
                vertex.z = NoiseGen.noise(vertex.x / 20, vertex.y / 20) * 1;
            }
            plane_geometry.computeFaceNormals();
            plane_geometry.computeVertexNormals();

            plane = new Physijs.HeightfieldMesh(
                plane_geometry,
                plane_material,
                0,
                50,
                50
            );
            plane.rotation.x = -Math.PI/2;
            //plane.position.y = -1.75;
            plane.receiveShadow = true;
            scene.add(plane);

            car = createCar(1,10,0);

            // model
            /*
            model = new Physijs.BoxMesh(new THREE.BoxGeometry(10,10,10),
                new THREE.MeshLambertMaterial({
                    color: 0xaa44aa
                })
            );
            model.position.set(0,40,0);
            scene.add(model);
            */

            keyLight = new THREE.DirectionalLight( 0xcccccc );
            keyLight.position.set(-59,120,74);
            keyLight.castShadow = true;
            scene.add(keyLight);  

            backLight = new THREE.AmbientLight(0xcccccc, 0.2);
            keyLight.castShadow = true;
            scene.add(backLight);

            initControl() ;
            animate();
            createShape();
            scene.simulate();
            
        }

        function onWindowResize(){
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
             renderer.setSize(window.innerWidth, window.innerHeight);
             render();
        }


        function animate() {             
            
            update();
            render(); 
            requestAnimationFrame(animate);

        }

        function update() {
             //记录当前被撞物体
             var curCollideMesh = null;
             var originPoint = car.position.clone();

             //遍历模型所有顶点
             for(let i=0; i<car.geometry.vertices.length; i++){
                 //顶点原坐标
                 let localVertex = car.geometry.vertices[i].clone();
                 //顶点经过变换后的坐标
                 let globalVertex = localVertex.applyMatrix4(car.matrix);
                 let directionVector = globalVertex.sub(car.position);

                 let ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
             
                 //射线是否与与物体产生交集
                 let collisionResults = ray.intersectObjects(collideMeshList);
                 if(collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() + 0.1){
                     crash = true;
                     curCollideMesh = collisionResults[0].object;
                     break;
                 }
                 crash = false;
             }

             for(let j=0; j<wheelArr.length; j++ ){
                 if(crash) {
                    break;
                 }
                 
                 var wheel = wheelArr[j].wheel_mesh;
                 originPoint = wheel.position.clone();
                 for(let i=0; i<wheel.geometry.vertices.length; i++){
                    let localVertex = wheel.geometry.vertices[i].clone();
                    //顶点经过变换后的坐标
                    let globalVertex = localVertex.applyMatrix4(wheel.matrix);
                    let directionVector = globalVertex.sub(wheel.position);

                    let ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
             
                    //射线是否与与物体产生交集
                    let collisionResults = ray.intersectObjects(collideMeshList);
                    if(collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() + 0.1){
                        crash = true;
                        curCollideMesh = collisionResults[0].object;
                        break;
                    }
                }
             }
                 
        


             //碰撞后发生的事件
             if(crash){
                 
                 explode_sound.play();
                 curCollideMesh.visible = false;
                 crash = false;
                 score.innerText = parseInt(score.innerText) + 10;
                 console.log('Crash! Score:' + score.innerText);
                                
             } else {

             }



             //清理待碰撞模型：一，已经被撞毁。二，掉落地表以下
             for(let i=0; i<collideMeshList.length; i++){
                 if(collideMeshList[i].position.y < -200 || curCollideMesh == collideMeshList[i]){
                     scene.remove(collideMeshList[i]);
                     collideMeshList.splice(i, 1);
                 }
             }
             curCollideMesh = null;

             if(collideMeshList.length < 4) {
                  createShape();
             }

        }

        function render(){
            //render
            stat.begin();
            renderer.render(scene, camera);
            stat.end();
        }

        

        function initControl() {
            gui = new dat.GUI();

            var option = {
                'Light X': keyLight.position.x,
                'Light Y': keyLight.position.y,
                'Light Z': keyLight.position.z,
            };

            //light
            var lightFolder = gui.addFolder('Light');
            lightFolder.add(option, 'Light X').min(-2000).max(2000)
                .onChange(function (value){
                    keyLight.position.x = value;
                });

            lightFolder.add(option, 'Light Y').min(-2000).max(2000)
                .onChange(function (value){
                    keyLight.position.y = value;
                });

            lightFolder.add(option, 'Light Z').min(-2000).max(2000)
                .onChange(function (value){
                    keyLight.position.z = value;
                });
        }

         function createCar(x, y, z){
            var materials = [];
            for(var i=0; i<6; i++){
                materials.push(Physijs.createMaterial(

                    new THREE.MeshBasicMaterial({
                        map: THREE.ImageUtils.loadTexture('img/' + i + '.png',{},function(){
                            renderer.render(scene, camera);
                        }),
                        overdraw: true
                    }),
                    .8,
                    .2
                ));
            }

            var wheel_material = Physijs.createMaterial(
                new THREE.MeshLambertMaterial({
                    color: 0xffffff
                }),
                0.8,
                0.5
            );
            
            var mycar = new Physijs.BoxMesh(new THREE.CubeGeometry(10,5, 5),
                new THREE.MeshFaceMaterial(materials)
            );
            mycar.castShadow = mycar.receiveShadow = true;
            mycar.position.set(x,y,z);
            scene.add(mycar);
            
            



            //轮子
            
            wheelArr.push({
                wheel_x: 3.5 + x ,
                wheel_y: 6.5 ,
                wheel_z: 3.5 + z ,
                wheel_constraint: null,
                wheel_mesh:null
            });
           
            wheelArr.push({
                wheel_x: -3.5 + x ,
                wheel_y: 6.5  ,
                wheel_z: -3.5+ z ,
                wheel_constraint: null,
                wheel_mesh:null
            });
           
            wheelArr.push({
                wheel_x: -3.5 + x ,
                wheel_y: 6.5  ,
                wheel_z: 3.5 + z,
                wheel_constraint: null,
                wheel_mesh:null
            });
            
            wheelArr.push({
                wheel_x: 3.5 + x ,
                wheel_y: 6.5  ,
                wheel_z: -3.5 + z ,
                wheel_constraint: null,
                wheel_mesh:null
            });
            

            var wheel_geometry = new THREE.CylinderGeometry(2, 2, 1, 10);

            
            wheelArr.forEach(function(data, index){
                var wheel = new Physijs.CylinderMesh(
                    wheel_geometry,
                    wheel_material,
                    500
                );
                
                
                wheel.rotation.x = Math.PI / 2;
                wheel.position.set(data.wheel_x,data.wheel_y,data.wheel_z);
                wheel.castShadow = wheel.receiveShadow = true;
                scene.add(wheel);
                wheelArr[index].wheel_mesh =  wheel;
                wheelArr[index].wheel_constraint = new Physijs.DOFConstraint(
                    wheel, mycar, new THREE.Vector3(data.wheel_x,data.wheel_y, data.wheel_z)
                );
                scene.addConstraint(wheelArr[index].wheel_constraint);
                wheelArr[index].wheel_constraint.setAngularLowerLimit({x:0, y:-Math.PI/8, z:1});
                wheelArr[index].wheel_constraint.setAngularUpperLimit({x:0, y:Math.PI/8, z:0});
            });

            

                
            /*    
            wheel.rotation.x = Math.PI / 2;
            wheel.position.set(data.wheel_x,data.wheel_y,data.wheel_z);
            wheel.castShadow = wheel.receiveShadow = true;
            scene.add(wheel);
            wheelArr[index].wheel_constraint = new Physijs.DOFConstraint(
                wheel, mycar, new THREE.Vector3(data.wheel_x,data.wheel_y, data.wheel_z)
            );
            scene.addConstraint(wheelArr[index].wheel_constraint);
            */


            return mycar;        
        }

        document.onkeydown = function(event){
              var e = event || window.event || arguments.callee.caller.arguments[0];
              var xFoward = 0.2 * Math.cos(rotate);
              var yFoward = 0.2 * Math.sin(rotate);
              switch(e.keyCode){
                case 38:
                //↑
                    
                    break;
                case 40:
                //↓
                    car.position.x -= 0.1;
                    break;
                case 37:
                //←
                    car.rotateY(Math.PI/180);
                    rotate += Math.PI/180;
                    break;w
                case 39:
                //→
                    car.rotateY(Math.PI/180);
                    rotate -= Math.PI/180;
                    break;
                case 87:
                //W
                    wheelArr[1].wheel_constraint.configureAngularMotor(2, 1, 0, -5, 2000);
                    wheelArr[1].wheel_constraint.enableAngularMotor( 2 );
                    wheelArr[2].wheel_constraint.configureAngularMotor(2, 1, 0, -5, 2000);
                    wheelArr[2].wheel_constraint.enableAngularMotor( 2 );
                    break;
                case 83:
                //S
                    wheelArr[1].wheel_constraint.configureAngularMotor(2, 1, 0, 5, 2000);
                    wheelArr[1].wheel_constraint.enableAngularMotor( 2 );
                    wheelArr[2].wheel_constraint.configureAngularMotor(2, 1, 0, 5, 2000);
                    wheelArr[2].wheel_constraint.enableAngularMotor( 2 );
                    break;
                case 65:
                //A
                    wheelArr[0].wheel_constraint.configureAngularMotor(1, -Math.PI/2, Math.PI/2, 1, 200);
                    wheelArr[3].wheel_constraint.configureAngularMotor(1, -Math.PI/2, Math.PI/2, 1, 200);
                    wheelArr[0].wheel_constraint.enableAngularMotor( 1 );
                    wheelArr[3].wheel_constraint.enableAngularMotor( 1 );
                    break;
                case 68:
                //D
                    wheelArr[0].wheel_constraint.configureAngularMotor(1, -Math.PI/2, Math.PI/2, -1, 200);
                    wheelArr[0].wheel_constraint.enableAngularMotor( 1 );
                    wheelArr[3].wheel_constraint.configureAngularMotor(1, -Math.PI/2, Math.PI/2, -1, 200);
                    wheelArr[3].wheel_constraint.enableAngularMotor( 1 );
                    break;
            }
         };

         document.onkeyup = function(event){
              var e = event || window.event || arguments.callee.caller.arguments[0];
              var xFoward = 0.2 * Math.cos(rotate);
              var yFoward = 0.2 * Math.sin(rotate);
              switch(e.keyCode){
                case 38:
                //↑
                    
                    break;
                case 40:
                //↓
                    car.position.x -= 0.1;
                    break;
                case 37:
                //←
                    car.rotateY(Math.PI/180);
                    rotate += Math.PI/180;
                    break;w
                case 39:
                //→
                    car.rotateY(Math.PI/180);
                    rotate -= Math.PI/180;
                    break;
                case 87:
                //W
                    wheelArr[1].wheel_constraint.disableAngularMotor( 2 );
                    wheelArr[2].wheel_constraint.disableAngularMotor( 2 );
                    break;
                case 83:
                //S
                    wheelArr[1].wheel_constraint.disableAngularMotor( 2 );
                    wheelArr[2].wheel_constraint.disableAngularMotor( 2 );
                    break;
                case 65:
                //A
                    wheelArr[0].wheel_constraint.disableAngularMotor( 1 );
                    wheelArr[3].wheel_constraint.disableAngularMotor( 1 );
                    break;
                case 68:
                //D
                    wheelArr[0].wheel_constraint.disableAngularMotor( 1 );
                    wheelArr[3].wheel_constraint.disableAngularMotor( 1 );
                    break;
            }
         };

         function createShape(){
             var box_geometry = new THREE.BoxGeometry( 8, 8, 8 );
             var material = new THREE.MeshLambertMaterial({
                 color: 0x888888
             });
             var shape = new Physijs.BoxMesh(
                 box_geometry,
                 material
             );
             shape.castShadow = shape.receiveShadow = true;
             shape.position.set(
                 Math.random() * 50 -20,
                 20,
                 Math.random() * 50 -20
             );
             shape.rotation.set(
                 Math.random() * Math.PI,
                 Math.random() * Math.PI,
                 Math.random() * Math.PI
             );
             //添加到碰撞检测列表中
             collideMeshList.push(shape);

             scene.add(shape);

         }

         
    </script>

</body>
</html>